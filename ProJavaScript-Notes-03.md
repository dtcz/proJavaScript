---
title: '重读 JS 高程（Chapter04）'
date: 2017-08-16 12:36:50
tags: javascript
category: javascript
---

## Chapter04. 变量、作用域和内存问题

### 基本类型和引用类型的值

ECMAScript 中的变量可能包含两种不同数据类型的值：基本类型值和引用类型值。**基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。**在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。

#### 动态的属性

不允许给基本类型值添加属性（尽管不会报错），只能给引用类型值动态地添加（删除）属性和方法。

#### 复制变量值

- 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
- 如果从一个变量向另一个变量复制引用类型的值，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

#### 传递参数

ECMAScript 中所有函数的参数都是**按值传递**的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为**访问变量有按值和按引用两种方式**，而**参数只能按值传递**。

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

``` javascript
function setName(obj) { 
    obj.name = "Nicholas"; 
    obj = new Object(); 
    obj.name = "Greg";
}

var person = new Object();
setName(person);
alert(person.name);    //"Nicholas"
```

如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值 为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。

**这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。**实际上，当在函数内部重写 obj 时，这 个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。**可以把 ECMAScript 函数的参数想象成局部变量。**

#### 检测类型

- 确定一个值是哪种基本类型可以使用 typeof 操作符。typeof 返回值是字符串，有六种可能： "number"，"string"，"boolean"，"object"，"function" 和 "undefined"。


- 确定一个值是哪种引用类型可以使用 instanceof 操作符。所有引用类型都是 Object 的实例。

<!-- more -->

### 执行环境和作用域

**执行环境**（execution context）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**（variable object），环境中定义的所有变量和函数都保存在这个对象中。执行环境有**全局执行环境**和**函数执行环境**之分：

- 全局执行环境是最外围的一个执行环境，浏览器中，全局执行环境被认为是 window 对象。
- 每个函数也有自己的执行环境，当执行流进入一个函数，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建**变量对象**的一个**作用域链**（scope chain）。作用域链的用途是保证有权访问执行环境的所有变量和函数能够**有序**地访问执行环境。作用域链的前端，始终都是当前执行的代码所在环境的**变量对象**。如果这个环境是函数，则将其**活动对象**（activation object）作为**变量对象**。全局执行环境的变量对象始终都是作用域链中的最后一个对象。

- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全局环境。
- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据。

**JavaScript 没有块级作用域。**使用 var 声明的变量会自动被添加到最接近的环境中，如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。

### 垃圾收集

JavaScript 有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。原理很简单，找出那些不再使用的变量，然后释放其占用的内容。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。

#### 标记清除

JavaScript 中最常用的垃圾收集方式是标记清除。当变量进入环境时，就将这个变量标记为“进入环境”。而当变量离开环境，则将其标记为“离开环境”。可以使用任何方式来标记变量。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记。 而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已已经无法访问到这些变量了。最后垃圾收集器完成**内存清除**工作，销毁那些带标记的值并回收它们所占用的内存空间。

主流浏览器都是标记清除式垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。

#### 引用计数

另一种不太常见的垃圾收集策略叫做引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个的引次数变成 0 时，则说明没有办法再访问这个值了。

然而这种方式最大的弊端就是在出现循环引用的状况下无法工作，指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用，这样会导致它们的引用次数永不为0，不会被垃圾收集器清除，导致大量内存无法回收，所以引用计数并不常用。这种情况下需要在对象不使用的时候设为null， 意味着切断变量与它此前引用的值之间的连接。

#### 管理内存

分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同 时执行的语句数量。

一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用(dereferencing)。例如：

``` javascript
function createPerson(name) {
    var locationPerson = new Object();
    localPerson.name = name;
    return localPerson;
}

var globalPerson = createPerson("Nicholas");
// 手工解除 globalPerson 的引用
globalPerson = null;
```

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 